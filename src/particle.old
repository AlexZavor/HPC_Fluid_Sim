/*****************************
*
*This is some old code I wrote, but then adapted it to use another code base
*because I think it worked a lot better. and since this project is about
*optimization, and not writing a fluid sim, I think it's ok.
*
*
*****************************/

#include "particle.hpp"
#include "graphics.hpp"
#include "config.hpp"
#include <math.h>

#ifdef __host__
    #include <cuda.h>
    #define CU_FLAG __host__ __device__
#else
    #define CU_FLAG
#endif

void particle_init1(particle* obj, vect2d pos, unsigned int radius){
	obj->pos = pos;
	obj->vel = ZERO_VECT;
	obj->radius = radius;
}

CU_FLAG double smoothKernel(double radius, double dist){
	if(dist>=radius)return 0;
	double volume = M_PI * pow(radius, 4)/6;
	return (radius-dist) * (radius-dist) / volume;
}

CU_FLAG double smoothKernelDerivative(double radius, double dist){
	if(dist>=radius) return 0;
	double scale = (double)12 / ((double)M_PI * pow(radius, 4));
	// const double scale = 0.000001;
	return (dist-radius)*scale;
}

CU_FLAG double calcDensity(particle* list, int size, int point_index){
	double density = 0;

	vect2d point = list[point_index].pos;
	for(int i = 0; i < size; i++){
		if(i == point_index){continue;}
		double dist = (list[i].pos - point).getMag();
		if (dist > SMOOTH_RADIUS) continue;
		double influence = smoothKernel(SMOOTH_RADIUS, dist);
		density += influence;
	}

	return density;
}

void particle_updateDensities(particle* list, int size){
	#if defined(_OPENMP)
		#pragma omp parallel for schedule(dynamic, 8)
	#endif
	for(int i = 0; i < size; i++){
		particle* particle = &list[i];
		particle->density = calcDensity(list, size, i);
		if (particle->density == 0) 
			particle->density = 0.00000000000001;
	}
}

CU_FLAG double densityToPressure(double density){
	double densityError = density-TARGET_DENSITY;
	double pressure = densityError * PRESSURE_FORCE;
	return pressure;
}

CU_FLAG double calcSharedPressure(double densityA, double densityB){
	double pressureA = densityToPressure(densityA);
	double pressureB = densityToPressure(densityB);
	return (pressureA + pressureB)/2;
}

CU_FLAG vect2d calcGradient(particle* list, int size, int point_index){
	vect2d gradient = ZERO_VECT;
	
	vect2d point = list[point_index].pos;
	for(int i = 0; i < size; i++){
		if(i == point_index){continue;}
		vect2d diff = (list[i].pos - point);
		double dist = diff.getMag();
		vect2d dir;
		if(dist == 0){
			dir = NORMAL_VECT;
		}else{
			dir = diff/dist;
		}
		double slope = smoothKernelDerivative(SMOOTH_RADIUS, dist);
		double density = list[point_index].density;
		double sharedPressure = calcSharedPressure(density, list[i].density);
		gradient += dir*slope*-1*sharedPressure/density;
	}

	return gradient;
}

CU_FLAG vect2d calcViscosityForce(particle* list, int size, int point_index){
	vect2d viscosityForce = ZERO_VECT;
	vect2d point = list[point_index].pos;
	for(int i = 0; i < size; i++){
		if(i == point_index){continue;}
		vect2d diff = (list[i].pos - point);
		double dist = diff.getMag();

		viscosityForce += (list[i].vel - list[point_index].vel) * smoothKernel(10, dist);
	}

	return viscosityForce * 0.2;
}


void particle_update(particle* list, int size, int point_index, double dt, input_t* input){
	#define vel (list[point_index].vel)
	#define pos (list[point_index].pos)

	particle* obj = &list[point_index];

	// Forces
	vel.y += GRAVITY*dt; // Gravity
	if(input->mouseLeft||input->mouseRight){ // Magic mouse
		vect2d mouse_vect = vect2d(input->mouseX, input->mouseY);
		vect2d force_vect = mouse_vect - pos;
		if(force_vect.getMag() < 40){
			vel += (force_vect*mouse_force*dt) * (input->mouseLeft?1:-1);
		}
	}
	vect2d pressure = calcGradient(list, size, point_index) / obj->density; // pressure
	vel += (pressure*-dt);

	// vel += calcViscosityForce(list, size, point_index);
	// vel *= 0.995; // viscosity

	// Velocity Clamping
	// if(vel.getMag()>(100/dt)){
	// 	vel = vel/2;
	// }
	pos += vel*dt;// velocity

	// Collision
	if (pos.y > SCREEN_HEIGHT-obj->radius){ // floor
		pos.y = SCREEN_HEIGHT-obj->radius;
		vel.y = -vel.y*BOUNCE_CONST;
		pos += vel*dt;// velocity
	}
	else if (pos.y < obj->radius){ // ceiling
		pos.y = obj->radius;
		vel.y = -vel.y*BOUNCE_CONST;
		pos += vel*dt;// velocity
	}
	if (pos.x < obj->radius){ // L wall
		pos.x = obj->radius;
		vel.x = -vel.x*BOUNCE_CONST;
		pos += vel*dt;// velocity
	}
	else if (pos.x > SCREEN_WIDTH-obj->radius){ // R wall
		pos.x = SCREEN_WIDTH-obj->radius;
		vel.x = -vel.x*BOUNCE_CONST;
		pos += vel*dt;// velocity
	}

	#undef vel
	#undef pos

}

void particle_draw1(particle* obj){
	double density = (obj->density-TARGET_DENSITY)*100000;

	if(density > 255)density = 255;
	if(density < -255)density = -255;
	
	graphics_fillCircle(obj->pos, obj->radius, _RGB(density>0?density:0, 0 ,density<0?-density:0));
	graphics_drawCircle(obj->pos, obj->radius, _RGB(PART_COLOR/2));
}